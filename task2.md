# 2. Shell工具与脚本
> 提前下载了vim编辑器

## 笔记
### 基本知识点
#### shell脚本
##### 
1. 在 bash 中为变量赋值的语法是 foo=bar，访问变量中存储的数值，其语法为 $foo。
2. ''定义的字符串为原义字符串，其中的变量不会被转义
3. ""定义的字符串会将变量值进行替换
4. bash支持if，case，while，for等控制流关键字
5. 特殊变量表示参数
> $0 - 脚本名
$1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。
$@ - 所有参数
$# - 参数个数
$? - 前一个命令的返回值
$$ - 当前脚本的进程识别码
!! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !! 再尝试一次。
$_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。
6. &&和||短路操作符用来进行条件判断

### shell工具
1. man(提供命令的用户手册)
2. find(用于递归查找文件并能够对其进行操作)，也可用fd和locate代替
3. grep(查找文件)
，可用ack，ag，rg代替
> 例(rg)
查找所有使用了 requests 库的文件
rg -t py 'import requests'
查找所有没有写 shebang 的文件（包含隐藏文件）
rg -u --files-without-match "^#!"
查找所有的foo字符串，并打印其之后的5行
rg foo -A 5
打印匹配的统计信息（匹配的行和文件的数量）
rg --stats PATTERN

### 查找shell命令和文件夹导航
1. history(以管理员方式访问shell中输入的历史命令)
2. Ctrl+R(对命令历史记录进行回溯搜索)
3. fasd，(针对频率和时效进行排序，使用命令z访问)
4. autojump(用j cool代替就行)

## 做题过程及运算结果
1. 阅读man文件,然后使用ls命令进行如下操作:
> 阅读 man ls ，然后使用 ls 命令进行如下操作：
所有文件（包括隐藏文件）：-a
文件打印以人类可以理解的格式输出 (例如，使用 454M 而不是 454279954): -h
文件以最近访问顺序排序：-t
以彩色文本显示输出结果 --color=auto
![img](./img/4480e0a1466ce266f4e0b01c73a7b44a.png)

2. 编写两个 bash 函数 marco 和 polo 执行下面的操作。 每当你执行 marco 时，当前的工作目录应当以某种形式保存，当执行 polo 时，无论现在处在什么目录下，都应当 cd 回到当时执行 marco 的目录。 为了方便 debug，你可以把代码写在单独的文件 marco.sh 中，并通过 source marco.sh 命令，（重新）加载函数。通过 source 来加载函数，随后可以在 bash 中直接使用。
> 看了半天vim介绍才看懂用法。。。。
> qa!(退出) help(查看介绍) wa(保存)
![img](./img/792559388846456c66805df80b3d168b.png)

3. 假设您有一个命令，它很少出错。因此为了在出错时能够对其进行调试，需要花费大量的时间重现错误并捕获输出。 编写一段 bash 脚本，运行如下的脚本直到它出错，将它的标准输出和标准错误流记录到文件，并在最后输出所有内容。 加分项：报告脚本在失败前共运行了多少次。
![img](./img/image.png)

4.您的任务是编写一个命令，它可以递归地查找文件夹中所有的 HTML 文件，并将它们压缩成 zip 文件。注意，即使文件名中包含空格，您的命令也应该能够正确执行。
1.首先创建所需的文件
>  mkdir html_root
  cd html_root
  touch {1..10}.html
  mkdir html
  cd html
  touch tw.html
2. 执行 find 命令
![img](./img/7790148be254ce05086b90b524e4509f.png)

5. > 编写一个命令或脚本递归的查找文件夹中最近使用的文件。更通用的做法，你可以按照最近的使用时间列出文件吗？ find . -type f -print0 | xargs -0 ls -lt | head -1 当文件数量较多时，上面的解答会得出错误结果，解决办法是增加 -mmin 条件，先将最近修改的文件进行初步筛选再交给 ls 进行排序显示 find . -type f -mmin -60 -print0 | xargs -0 ls -lt | head -10
![img](./img/70da77ecdd9a3b83e0e257239df27a64.png)